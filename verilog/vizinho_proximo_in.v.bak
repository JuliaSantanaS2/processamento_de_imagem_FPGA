// Modulo para ampliacao (Zoom In 2x) por Vizinho Mais Proximo.
// Este algoritmo e funcionalmente identico a Replicacao de Pixel.
module vizinho_proximo_in (
    input  wire clk,
    input  wire resetn,

    // Sinais de controle
    input  wire start,             // Pulso para iniciar o processamento de uma nova imagem
    input  wire [9:0] largura_in,   // Largura da imagem de entrada
    input  wire [9:0] altura_in,    // Altura da imagem de entrada

    // Entrada de dados
    input  wire [7:0] pixel_in,

    // Saida de dados
    output reg  [7:0] pixel_out,
    output reg  pixel_out_valid,
    output reg  processing_done   // Pulso que indica o fim do processamento da imagem
);

    // Dimensoes maximas que o hardware suporta
    localparam LARGURA_MAXIMA = 640;
    localparam LARGURA_SAIDA_MAXIMA = LARGURA_MAXIMA * 2;

    // Estados da maquina de estados
    localparam [1:0] S_IDLE      = 2'b00, // Aguardando o sinal de start
                      S_RECEBENDO = 2'b01,
                      S_ENVIANDO  = 2'b10;

    reg [1:0] estado;

    // Registradores para armazenar as dimensoes da imagem atual
    reg [9:0] largura_reg;
    reg [9:0] altura_reg;

    // Buffer para armazenar uma linha de pixels expandida (tamanho maximo)
    reg [7:0] linha_expandida [0:LARGURA_SAIDA_MAXIMA-1];

    // Contadores
    reg [9:0] x_in_count;
    reg [9:0] y_in_count;
    reg [10:0] x_out_count;
    reg row_out_count;

    always @(posedge clk or negedge resetn) begin
        if (!resetn) begin
            // Reset de todos os registradores
            estado          <= S_IDLE;
            largura_reg     <= 0;
            altura_reg      <= 0;
            x_in_count      <= 0;
            y_in_count      <= 0;
            x_out_count     <= 0;
            row_out_count   <= 0;
            pixel_out       <= 8'd0;
            pixel_out_valid <= 1'b0;
            processing_done <= 1'b0;
        end else begin
            // Por padrao, o sinal de 'done' fica em baixo
            processing_done <= 1'b0;

            case (estado)
                S_IDLE: begin
                    pixel_out_valid <= 1'b0;
                    if (start) begin
                        // Captura as dimensoes da imagem
                        largura_reg <= (largura_in > LARGURA_MAXIMA) ? LARGURA_MAXIMA : largura_in;
                        altura_reg  <= altura_in;
                        
                        // Reseta os contadores
                        y_in_count  <= 0;
                        x_in_count  <= 0;
                        x_out_count <= 0;
                        row_out_count <= 0;
                        estado      <= S_RECEBENDO;
                    end
                end

                S_RECEBENDO: begin
                    pixel_out_valid <= 1'b0;

                    // Duplica o pixel de entrada no buffer
                    linha_expandida[x_in_count * 2]     <= pixel_in;
                    linha_expandida[x_in_count * 2 + 1] <= pixel_in;

                    if (x_in_count == largura_reg - 1) begin
                        x_in_count <= 0;
                        estado     <= S_ENVIANDO;
                    end else begin
                        x_in_count <= x_in_count + 1;
                    end
                end

                S_ENVIANDO: begin
                    pixel_out_valid <= 1'b1;
                    pixel_out       <= linha_expandida[x_out_count];

                    if (x_out_count == (largura_reg * 2) - 1) begin
                        x_out_count <= 0;

                        if (row_out_count == 1'b1) begin // Terminou de enviar a segunda linha
                            row_out_count <= 1'b0;
                            
                            if (y_in_count == altura_reg - 1) begin // Terminou a imagem inteira
                                processing_done <= 1'b1;
                                estado          <= S_IDLE;
                            end else begin // Ainda ha mais linhas na imagem
                                y_in_count <= y_in_count + 1;
                                estado     <= S_RECEBENDO;
                            end
                        end else begin // Terminou de enviar a primeira linha, envia a segunda
                            row_out_count <= 1'b1;
                        end
                    end else begin
                        x_out_count <= x_out_count + 1;
                    end
                end

                default: begin
                    estado <= S_IDLE;
                end
            endcase
        end
    end

endmodule