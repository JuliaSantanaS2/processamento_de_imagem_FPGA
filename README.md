# üìù Relat√≥rio T√©cnico - Coprocessador em FPGA

## üìë Sum√°rio
- üéØ [Introdu√ß√£o](#introdu√ß√£o)
- üéØ [Objetivos e Requisitos do Problema](#objetivos-e-requisitos-do-problema)
- üõ†Ô∏è [Recursos Utilizados](#recursos-utilizados)

- üöÄ [Desenvolvimento e Descri√ß√£o em Alto N√≠vel](#desenvolvimento-e-descri√ß√£o-em-alto-n√≠vel)
- üéõÔ∏è [Unidade de Controle](#unidade-de-controle)
- üßÆ [ULA (Unidade L√≥gica e Aritm√©tica)](#unidade-l√≥gica-aritm√©tica)
- üß™ [Testes, Simula√ß√µes, Resultados e Discuss√µes](#testes-simula√ß√µes-resultados-e-discuss√µes)

---

## Introdu√ß√£o

A evolu√ß√£o das tecnologias de processamento de imagem tem impulsionado avan√ßos significativos em sistemas de vigil√¢ncia e exibi√ß√£o em tempo real, demandando solu√ß√µes eficientes para manipula√ß√£o e redimensionamento de imagens. Neste contexto, a implementa√ß√£o de algoritmos de interpola√ß√£o visual em hardware dedicado, como FPGAs (Field-Programmable Gate Arrays), destaca-se pela capacidade de oferecer alto desempenho e baixa lat√™ncia, caracter√≠sticas essenciais para aplica√ß√µes cr√≠ticas.

O presente projeto insere-se no √¢mbito do desenvolvimento de um m√≥dulo embarcado para redimensionamento de imagens, especificamente projetado para operar como um coprocessador gr√°fico autossuficiente na plataforma DE1-SoC. Utilizando a linguagem Verilog para s√≠ntese na FPGA, o sistema √© capaz de executar algoritmos de amplia√ß√£o (zoom in) e redu√ß√£o (zoom out) por meio de t√©cnicas como **Vizinho Mais Pr√≥ximo** (Nearest Neighbor Interpolation), **Replica√ß√£o de Pixel** (Pixel Replication), **Decima√ß√£o** (Nearest Neighbor for Zoom Out) e **M√©dia de Blocos** (Block Averaging), atendendo aos requisitos de processamento em tempo real.

Al√©m da implementa√ß√£o em hardware, o projeto visa permitir futuras expans√µes do sistema. O controle √© realizado por meio de chaves e bot√µes f√≠sicos da placa, e a sa√≠da processada √© exibida via interface VGA, proporcionando uma solu√ß√£o completa e integrada.

Este relat√≥rio detalha o processo de desenvolvimento, desde a concep√ß√£o arquitetural at√© a valida√ß√£o pr√°tica, abordando aspectos como mapeamento de mem√≥ria, intera√ß√£o hardware-software e otimiza√ß√µes para efici√™ncia computacional. Atrav√©s de uma documenta√ß√£o robusta e c√≥digo devidamente comentado, busca-se n√£o apenas cumprir os objetivos t√©cnicos, mas tamb√©m fornecer um referencial para projetos futuros na √°rea de sistemas digitais reconfigur√°veis.


## üìã Requisitos do Projeto
1. O c√≥digo deve ser escrito em linguagem Verilog;
2. O sistema s√≥ poder√° utilizar os componentes dispon√≠veis na placa;
3. Realizar Zoom In e Zoom Out em passos de 2X,atrav√©s dos algoritmos:
1. [Nearest Neighbor Interpolation](#nearest-neighbor-interpolation)
3. [Replica√ß√£o de Pixel](#pixel-replication)
4. [Decima√ß√£o/Amostragem](#amostragem)
6. [M√©dia de blocos](#block-averaging)
4. As imagens s√£o representadas em escala de cinza e cada elemento da imagem
(pixel) dever√° ser representado por um n√∫mero inteiro de 8 bits.
5. Devem ser utilizados chaves e/ou bot√µes para determinar a amplia√ß√£o e redu√ß√£o da imagem;
6. O coprocessador deve ser compat√≠vel com o processador ARM (Hard Processor
System - HPS) para viabilizar o desenvolvimento das pr√≥ximas etapas.


## üõ†Ô∏è Recursos Utilizados

### üîß Ferramentas

#### üíª Quartus Prime

- S√≠ntese e Compila√ß√£o:

O Quartus Prime √© utilizado para compilar o projeto em Verilog, convertendo a descri√ß√£o HDL em uma implementa√ß√£o f√≠sica adequada para a FPGA. Durante esse processo, o compilador realiza a s√≠ntese l√≥gica, o mapeamento e o ajuste de layout (place and route), otimizando as rotas l√≥gicas e a aloca√ß√£o dos recursos internos da FPGA, conforme as recomenda√ß√µes descritas no User Guide: Compiler.

- Refer√™ncia oficial:
[**Quartus Prime Guide**](https://www.intel.com/content/www/us/en/support/programmable/support-resources/design-software/user-guides.html)

#### üíª FPGA DE1-SoC

- Especifica√ß√µes T√©cnicas:

A placa DE1-SoC, baseada no FPGA Cyclone V SoC (modelo 5CSEMA5F31C6N), conta com aproximadamente 85K elementos l√≥gicos (LEs), 4.450 Kbits de mem√≥ria embarcada e 6 blocos DSP de 18x18 bits. Essas caracter√≠sticas permitem a implementa√ß√£o de designs complexos e o processamento paralelo de dados.

- Perif√©ricos Utilizados:
- Acesso √† Chip Memory:
O design utiliza diretamente a mem√≥ria embarcada na FPGA para armazenamento tempor√°rio de dados e matrizes, eliminando a necessidade de interfaces externas para mem√≥ria DDR3.

- Refer√™ncia oficial:
[**Manual da Placa**](https://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&No=836&PartNo=4)

### üîß Recurso

#### üîå VGA module
M√≥dulo respons√°vel pela comunica√ß√£o entre o monitor e a mem√≥ria (no caso, On Chip memory),utilizado para exibir as imagens processadas ou n√£o atrav√©s do conector VGA.

As sa√≠das next_x e next_y do m√≥dulo VGA definem o endere√ßo de leitura para a mem√≥ria e acessa as informa√ß√µes de cor dos pixels.

Controlar uma tela VGA requer a manipula√ß√£o de dois pinos de sincroniza√ß√£o digital e tr√™s pinos anal√≥gicos coloridos (VERMELHO, VERDE e AZUL). Um dos pinos de sincroniza√ß√£o, HSYNC, informa √† tela quando mover para uma nova linha de pixels. O outro pino de sincroniza√ß√£o, VSYNC, informa √† tela quando iniciar um novo quadro. O protocolo √© descrito abaixo, tanto textualmente quanto visualmente.


- Refer√™ncia oficial:
[**Verilog VGA module**](https://vanhunteradams.com/DE1/VGA_Driver/Driver.html)



## ü§ñ Algoritmos
### Nearest Neighbor Interpolation
A interpola√ß√£o por vizinho mais pr√≥ximo √© um dos m√©todos mais simples para amplia√ß√£o de imagem. Ele mapeia o valor de cada pixel ampliado para o valor do pixel mais pr√≥ximo da posi√ß√£o original. Esse m√©todo resulta em uma amplia√ß√£o com bordas vis√≠veis e com um efeito pixelado. √â eficiente em termos de tempo de execu√ß√£o e ideal para sistemas embarcados, como o FPGA, onde o desempenho em tempo real √© crucial.
### Block Averaging
A m√©dia de blocos √© um algoritmo utilizado para reduzir a resolu√ß√£o de uma imagem. Nesse processo, grupos de pixels adjacentes s√£o combinados, tirando-se a m√©dia de seus valores para criar um √∫nico pixel representando o bloco. Esse processo √© especialmente √∫til para zoom out, pois suaviza a imagem resultante, eliminando a "dureza" associada a outras t√©cnicas de redu√ß√£o. Ele √© particularmente √∫til quando se deseja preservar a suavidade visual ao reduzir a resolu√ß√£o de uma imagem.

### Pixel Replication
Na replica√ß√£o de pixel, o algoritmo simplesmente copia o valor de um pixel para preencher m√∫ltiplos pixels vizinhos na nova imagem ampliada. Por exemplo, ao aumentar a imagem em 2x, cada pixel √© duplicado para preencher quatro novas posi√ß√µes. Embora esse m√©todo n√£o produza uma imagem suavizada, ele √© r√°pido e eficiente, o que o torna √∫til para sistemas com restri√ß√µes de tempo de processamento.



### üöÄ Desenvolvimento e Descri√ß√£o em Alto N√≠vel
O projeto foi desenvolvido com foco em garantir **fluxo cont√≠nuo de pixels** e **uso eficiente dos recursos l√≥gicos da FPGA**.
üëâ A imagem de entrada padr√£o possui resolu√ß√£o **160√ó120 pixels**, enquanto a interface VGA trabalha em **640√ó480 pixels**, permitindo validar o processo de redimensionamento em hardware.

---

## üó∫Ô∏è Diagrama√ß√£o do Sistema
Como estamos lidando com um sistema que envolve m√∫ltiplos recursos da placa, foi necess√°rio realizar uma **diagrama√ß√£o e modulariza√ß√£o inicial**, com o objetivo de orientar o desenvolvimento do projeto de forma gradual e organizada.

1. O desenvolvimento iniciou-se com a importa√ß√£o e adapta√ß√£o do m√≥dulo de exibi√ß√£o VGA (`vga_module`).
- Respons√°vel por gerar os sinais de sincroniza√ß√£o **HSYNC** e **VSYNC**, al√©m das coordenadas `(next_x, next_y)`.
- Essa etapa permitiu validar visualmente os endere√ßos e a sincroniza√ß√£o antes de integrar o processamento.

2. Em seguida, foi trabalhada a **mem√≥ria on-chip**, incluindo a RAM (`imagem_mod`) e as ROMs em formato `.mif` (`imagem` e `imagem_test`).
- **RAM**: framebuffer de 8 bits para pixels processados.
- **ROMs**: imagens original de 160√ó120.

3. Implementa√ß√£o e teste dos algoritmos de redimensionamento com fator de 2x ou 4x:
- **Nearest Neighbor**
- **Replica√ß√£o de Pixel**
- **M√©dia de Blocos**
- **Decima√ß√£o**

Cada um foi validado via `pixel_out_valid`, garantindo integridade antes de armazenar os dados.
- O algoritmo/estado do coprocessador √© controlado pelas chaves `SW[8:2]` (sele√ß√£o do algoritmo e fator de escala).

4. Ap√≥s a valida√ß√£o, os pixels processados foram gravados na RAM.
- Escrita √∫nica por pixel.
- Leitura cont√≠nua pelo VGA.

Essa abordagem incremental e modular garantiu confiabilidade e sincronismo no fluxo de pixels.

## üèúÔ∏è Modulariza√ß√£o e Fluxo de Pixels
O sistema segue arquitetura modular, em que cada m√≥dulo executa uma fun√ß√£o espec√≠fica.
O fluxo de pixels percorre desde a **ROM**, passa pelo **processamento**, √© armazenado em **RAM** e finalmente exibido no **VGA**.

### üì¶ 1. M√≥dulos de Mem√≥ria ROM
- **Fun√ß√£o**: Armazenar imagens originais em formato `.mif`.
- **M√≥dulos**:
- `imagem` ‚Üí resolu√ß√£o **160√ó120**.
- `imagem_test` ‚Üí resolu√ß√£o **320√ó240**.
- **Sa√≠da**: pixel de 8 bits endere√ßado por `(x, y)` do VGA.

### üéõÔ∏è 2. Unidade de Controle (`main.v`)
- Divide o clock (`clk_50 ‚Üí clk_25`).
- Gera sinais de reset e controla estados de processamento.
- Conta os pixels processados e impede reescrita cont√≠nua na RAM.
- Encaminha ao coprocessador o **estado/algoritmo ativo**, definido pelas chaves `SW[3:0]`.

### ‚öôÔ∏è 3. Coprocessador
- **Fun√ß√£o**: Redimensionar a imagem original 160√ó120.
- **Algoritmos** (selecionados via `SW[3:0]`):
- `0001` ‚Üí Nearest Neighbor
- `0010` ‚Üí Replica√ß√£o de Pixel
- `0100` ‚Üí M√©dia de Blocos
- `1000` ‚Üí Decima√ß√£o
- **Processo**:
- Aplica o algoritmo selecionado.
- Usa `pixel_out_valid` para handshake e sincronismo.
- **Sa√≠da**: pixel redimensionado pronto para escrita na RAM.

### üìÇ 4. Mem√≥ria RAM (`imagem_mod`)
- **Fun√ß√£o**: Armazenar a imagem processada.
- **Escrita**: ocorre uma √∫nica vez, controlada pelo `pixel_count`.
- **Leitura**: cont√≠nua, sincronizada com `(next_x, next_y)` do VGA.

### üñ•Ô∏è 5. Interface VGA (`vga_module`)
- **Fun√ß√£o**: Exibir a imagem no monitor.
- **Entradas**: pixel vindo diretamente da ROM, do processador ou da RAM.
- **Sa√≠da**: sinais digitais **RGB (8 bits cada)**, **HSYNC**, **VSYNC**, **BLANK**, **SYNC**, **CLK**.
- **Extra**: gera as coordenadas de varredura para endere√ßar ROM e RAM.


###  6. Phase-Locked Loop, (`pll`)
- **Fun√ß√£o**: circuito eletr√¥nico que multiplica e ajusta fase da frequncia
- **Entradas**: Sinal de clock de refer√™ncia
- **Sa√≠da**:Sinais de clock de sa√≠da com frequ√™ncias e fases controladas.


---

### üîÑ Sequ√™ncia do Fluxo de Dados
1. **ROM** fornece os pixels originais (160√ó120 ou 320√ó240).
2. **Coprocessador** aplica o algoritmo selecionado via `SW[3:0]`.
3. **RAM** armazena a imagem processada em 320√ó240.
4. **Unidade de Controle** organiza o fluxo de escrita/leitura.
5. **VGA** renderiza a imagem em 640√ó480.

![](https://github.com/JuliaSantanaS2/processamento_de_imagem_FPGA/blob/main/fluxodedados.png?raw=true)

****


## üì¶ Mem√≥ria On-Chip e Integra√ß√£o com o Coprocessador

A mem√≥ria on-chip da FPGA DE1-SoC √© respons√°vel por armazenar a **imagem processada** antes de sua exibi√ß√£o via VGA.
No projeto, foi utilizada uma **RAM de 8 bits**, suficiente para guardar pixels em escala de cinza (0‚Äì255), operando como **framebuffer** intermedi√°rio entre os algoritmos e o VGA.

Diferente de arquiteturas que utilizam mem√≥ria para instru√ß√µes, aqui a mem√≥ria √© **dedicada exclusivamente ao armazenamento de dados de imagem**, garantindo que cada pixel processado seja escrito **uma √∫nica vez** e lido de forma cont√≠nua pelo VGA.

---

### ‚öôÔ∏è Par√¢metros da RAM (`imagem_mod`)

- **address [18:0]** ‚Üí Endere√ßo de leitura/escrita.
- Durante o processamento: recebe `pixel_count` sequencial para percorrer toda a imagem.
- Durante a exibi√ß√£o VGA: recebe `rom_address_M`, gerado pelas coordenadas `(next_x, next_y)`.
- Sele√ß√£o escrita/leitura feita via sinal `processing_done` do coprocessador.

- **clock (clk_25)** ‚Üí Sinal derivado de `clk_50`.
- Sincroniza escrita de pixels processados e leitura cont√≠nua pelo VGA.

- **data [7:0]** ‚Üí Pixel de entrada no barramento de 8 bits, vindo do coprocessador (`pixel_out`).

- **wren** ‚Üí Habilita escrita na RAM.
- Ativado enquanto `pixel_out_valid = 1` e at√© que todos os pixels sejam gravados (`pixel_count == IMG_SIZE - 1`).
- Ap√≥s o t√©rmino do processamento (`processing_done = 1`), `wren` √© desativado permanentemente.

- **q [7:0]** ‚Üí Pixel de sa√≠da lido pelo VGA durante a varredura da tela.

- **pixel_in_ready** ‚Üí Sinal do coprocessador indicando que ele est√° pronto para receber novos pixels.
- Garante **handshake** entre o m√≥dulo de entrada e o coprocessador, evitando perda de dados.

---

### üîÑ Ciclo de uso da RAM

1. **Escrita**
- O pixel processado √© armazenado em `ram_address_write`.
- Cada m√≥dulo de processamento (`replicacao_pixel`, `media_de_blocos`, `vizinho_proximo_in`, `vizinho_proximo_out`) gera `pixel_out` e `pixel_out_valid`, selecionados pelo **mux do coprocessador** de acordo com `SW[3:0]`.
- Processo continua at√© que todos os pixels da imagem (**320√ó240**) sejam gravados, acionando `processing_done`.

2. **Leitura**
- Ap√≥s o t√©rmino da escrita, os pixels s√£o acessados em tempo real pelo VGA via `ram_address_read`.
- Permite exibir a imagem final de forma est√°vel e cont√≠nua no monitor.

---

### üì• Fluxo de Pixels e Handshake

- Cada algoritmo possui sinais pr√≥prios de **ready/valid**:
- `out_algoritmo_valid_*` ‚Üí indica pixel v√°lido.
- `ready_algoritmo_*` ‚Üí indica que o algoritmo est√° pronto para receber/entregar o pr√≥ximo pixel.
- O **coprocessador** faz o mux das sa√≠das com base em `SW[3:0]`, selecionando:
- 0000 ‚Üí passthrough da ROM (`pixel_in`).
- 0001 ‚Üí replica√ß√£o de pixel
- 0010 ‚Üí nearest neighbor (zoom in)
- 0100 ‚Üí nearest neighbor (zoom out)
- 1000 ‚Üí m√©dia de blocos

- **pixel_in_ready** do coprocessador √© o ready do algoritmo selecionado, garantindo **handshake correto** e evitando overflow.

---

### üîé Leitura das ROMs

- A leitura de pixels da ROM √© feita pelo **VGA controller (`vga_module`)**, que gera `(next_x, next_y)`.
- Endere√ßos das ROMs calculados como `(next_y * IMG_WIDTH + next_x)`.
- Pixels podem ser enviados diretamente para o VGA ou para o coprocessador, garantindo **sincronismo completo**.

---

üìå Em resumo:
- A RAM funciona como **framebuffer da imagem processada**, n√£o armazena instru√ß√µes.
- O coprocessador controla a escrita usando **pixel_out_valid**, **processing_done** e **pixel_in_ready**.
- A sele√ß√£o de algoritmo via `SW[5:2]` permite alternar dinamicamente entre diferentes m√©todos de redimensionamento.


## üèóÔ∏è Arquitetura Geral

### üîß M√≥dulo Principal (`main.v`)
- Instancia os m√≥dulos de leitura, processamento, mem√≥ria e VGA,funcionando como uma unidade de controle.
- Divide o clock (**50 MHz ‚Üí 25 MHz**) e gera sinais de reset.
- Multiplica o clock para **100MHz**
- Registra estado do processo atrav√©s do reset autom√°tico e manual (SW[9])
    + Zera contadores
    + M√°quinas de estado voltam para o estado IDLE (ocioso).
    + Limpa flags
- Controla endere√ßos de leitura e escrita da RAM.
- Encaminha para o coprocessador o **estado/algoritmo ativo** de acordo com as chaves (`SW[5:2]`).
- Permite selecionar dinamicamente entre imagem original, imagem processada ou alternativa.

---

### ‚öôÔ∏è Subm√≥dulos Especializados
| M√≥dulo | Opera√ß√£o | Descri√ß√£o |
|------------------------|-----------------|---------------------------------------------------------------------------|
| `imagem` | ROM 160√ó120 | Armazena a imagem original em baixa resolu√ß√£o |
| `imagem_test` | ROM 320√ó240 | Alternativa de imagem em resolu√ß√£o maior |
| `replicacao_pixel` | Processamento | Realiza **replica√ß√£o de pixels** (zoom in / redimensionamento) |
| `media_pixel` | Processamento | Calcula **m√©dia de blocos** para suavizar e redimensionar a imagem |
| `vizinho_proximo_in` | Processamento | Implementa **Nearest Neighbor (zoom in)** |
| `vizinho_proximo_out` | Processamento | Implementa **Nearest Neighbor (zoom out / decima√ß√£o)** |
| `imagem_mod` | RAM | Framebuffer de 8 bits. Guarda a imagem processada para leitura posterior |
| `vga_module` | Exibi√ß√£o | Gera sinais **RGB, HSYNC, VSYNC**, al√©m das coordenadas `(next_x,next_y)` |

---

## üîç Detec√ß√£o de Overflow (Handshake Overflow)
Foi implementado um **mecanismo de handshake** para evitar perda de dados entre m√≥dulos.
O problema de **overflow** ocorre quando a taxa de produ√ß√£o de pixels √© maior que a de consumo.

- **Buffer cheio** ‚Üí ativa sinal de `stall` na FSM.
- **Lat√™ncia do VGA** ‚Üí controlada via protocolo **ready/valid**.
- **Solu√ß√£o** ‚Üí pixels s√≥ avan√ßam quando o pr√≥ximo m√≥dulo est√° pronto, garantindo integridade da imagem.

---

## üéõÔ∏è Sele√ß√£o de Algoritmos
As chaves da placa determinam qual **algoritmo/estado** o coprocessador executa:

| SW[5:2] | Algoritmo / Estado |
|---------|-----------------------------|
| `0001` | Nearest Neighbor (Zoom In) |
| `0010` | Replica√ß√£o de Pixel |
| `0100` | M√©dia de Blocos |
| `1000` | Nearest Neighbor (Zoom Out) |
| Outros | Exibi√ß√£o direta da ROM/RAM |

---

## üß™ Testes e Simula√ß√µes

- **Simula√ß√£o (Icarus Verilog/ModelSim)**: valida√ß√£o isolada de cada m√≥dulo utilizando amostras reduzidas de pixels em escala de cinza (ex.: 8√ó8 ou 16√ó16) para observar o comportamento interno dos algoritmos.
- **Integra√ß√£o (Quartus Prime II)**: verifica√ß√£o do fluxo completo, da ROM at√© a VGA, com monitoramento dos sinais de handshake e endere√ßos de RAM.
- **Implementa√ß√£o (DE1-SoC)**: execu√ß√£o pr√°tica com imagens em `.mif` de 160√ó120 redimensionadas para 640√ó480, permitindo validar visualmente o resultado.


### üîé Observa√ß√£o de Waveforms

Durante a simula√ß√£o, foram geradas waveforms para cada algoritmo aplicado:

| Algoritmo | Objetivo | Observa√ß√µes nas Waveforms |
|----------------------------|-----------------------------------------------|----------------------------------------------------|
| **Nearest Neighbor (Zoom In)** | Amplia√ß√£o da imagem | Pixels replicados seguindo o valor do vizinho mais pr√≥ximo, mantendo bordas vis√≠veis. |
| **Pixel Replication** | Amplia√ß√£o simples | Cada pixel duplicado em blocos 2√ó2 (ou conforme fator), r√°pido e sem suaviza√ß√£o. |
| **Block Averaging** | Redu√ß√£o de resolu√ß√£o | Pixels de blocos s√£o combinados via m√©dia, suavizando a imagem final. |
| **Decima√ß√£o / Nearest Neighbor (Zoom Out)** | Redu√ß√£o da imagem | Sele√ß√£o de pixels estrat√©gicos, mantendo propor√ß√£o, mas perdendo detalhes finos. |

> üí° Para observa√ß√£o clara em waveform, utilizamos amostras de pixels pequenas em escala de cinza. Isso permite visualizar cada ciclo de clock, sinais `pixel_in_valid`, `pixel_out_valid`, `wren` e os endere√ßos da RAM (`ram_address_write`) sem precisar renderizar toda a imagem.

### üñºÔ∏è Exemplos de Waveforms
<p align="center">
<img src="images/waveform_nearest_neighbor.png" width="500"/>
<img src="images/waveform_pixel_replication.png" width="500"/>
<img src="images/waveform_block_averaging.png" width="500"/>
<img src="images/waveform_decimation.png" width="500"/>
</p>

> As imagens acima ilustram como os sinais internos mudam a cada ciclo de clock, mostrando escrita em RAM e processamento de pixels.

---

## üìà An√°lise dos Resultados
- Processamento em tempo real sem perda de pixels.
- Imagens originais de 160√ó120 foram ampliadas para 640√ó480 e vice versa via coprocessador, observando no VGA:
- Amplia√ß√£o correta sem distor√ß√µes.
- Diferentes modos selecion√°veis via `SW[3:0]` (imagem original, processada, RAM, alternativa 320√ó240).
- Lat√™ncia m√≠nima, sem perda de pixels, confirmando a efic√°cia do handshake workflow.
- Handshake overflow garantiu sincroniza√ß√£o est√°vel sem sobrescrita de pixels ou vazementos.

---

## üìâ Desempenho e Uso de Recursos
- Uso eficiente de recursos l√≥gicos da FPGA.
- Pipeline otimizado para throughput cont√≠nuo.
- Buffer garantiu equil√≠brio entre produ√ß√£o e consumo.

---

## üí≠ Discuss√µes e Melhorias Futuras
- Adi√ß√£o de novos algoritmos de interpola√ß√£o para zoom in.
- Suporte a diferentes resolu√ß√µes al√©m da matriz fixa.
- Expans√£o para imagens RGB de 24 bits.

## üèÅ Conclus√£o

O projeto demonstrou a capacidade de processar e redimensionar imagens em **tempo real** utilizando um coprocessador gr√°fico em FPGA, com:

- Controle eficiente de mem√≥ria RAM on-chip como framebuffer.
- Sincroniza√ß√£o precisa via handshake workflow, evitando overflow.
- Modularidade que permite f√°cil inclus√£o de novos algoritmos.
- Valida√ß√£o completa via simula√ß√£o e implementa√ß√£o pr√°tica em DE1-SoC.

O trabalho abre caminho para futuras expans√µes, como suporte a imagens RGB, diferentes resolu√ß√µes e algoritmos mais sofisticados de interpola√ß√£o.
	
## ‚úçÔ∏è Colaboradores

Este projeto foi desenvolvido por:

- [**Julia Santana**](https://github.com/)
- [**Maria Clara**](https://github.com/)
- [**Vitor D√≥rea**](https://github.com/)

Agradecimentos ao(a) professor(a) [**Angelo Duarte**] pela orienta√ß√£o.
