# üìù Relat√≥rio T√©cnico - Coprocessador  em FPGA

## üìë Sum√°rio

- üéØ [Objetivos e Requisitos do Problema](#objetivos-e-requisitos-do-problema)
- üõ†Ô∏è [Recursos Utilizados](#recursos-utilizados)
  - üîß [Quartus Prime](#quartus-prime)
  - üíª [FPGA DE1-SoC](#fpga-de1-soc)
- üöÄ [Desenvolvimento e Descri√ß√£o em Alto N√≠vel](#desenvolvimento-e-descri√ß√£o-em-alto-n√≠vel)
  - üéõÔ∏è [Unidade de Controle](#unidade-de-controle)
  - üßÆ [ULA (Unidade L√≥gica e Aritm√©tica)](#unidade-l√≥gica-aritm√©tica)
- üß™ [Testes, Simula√ß√µes, Resultados e Discuss√µes](#testes-simula√ß√µes-resultados-e-discuss√µes)

---

## üåü Introdu√ß√£o



## üéØ Objetivos e Requisitos do Problema



### üìã Requisitos do Projeto
1. O c√≥digo deve ser escrito em linguagem Verilog;
2. O sistema s√≥ poder√° utilizar os componentes dispon√≠veis na placa;
3. Implementa√ß√£o dos seguintes algoritmos para o redimensionamento
das imagens, ambos em passos de 2X:
  3.1. Aproxima√ß√£o (Zoom in)
  3.1.1. Vizinho Mais Pr√≥ximo (Nearest Neighbor Interpolation);
  3.1.2. Replica√ß√£o de Pixel (Pixel Replication / Block Replication)
  3.2. Redu√ß√£o (Zoom out)
  3.2.1. Decima√ß√£o / Amostragem (Nearest Neighbor for Zoom Out)
  3.2.2. M√©dia de Blocos (Block Averaging / Downsampling with Averaging)
1. As imagens s√£o representadas em escala de cinza e cada elemento da imagem
(pixel) dever√° ser representado por um n√∫mero inteiro de 8 bits.
4.5. Devem ser utilizados chaves e/ou bot√µes para determinar a amplia√ß√£o e
redu√ß√£o da imagem;
4.6. O coprocessador deve ser compat√≠vel com o processador ARM (Hard Processor
System - HPS) para viabilizar o desenvolvimento das pr√≥ximas etapas.


## üõ†Ô∏è Recursos Utilizados

### üîß Ferramentas 

#### üíª Quartus Prime

- S√≠ntese e Compila√ß√£o:

O Quartus Prime √© utilizado para compilar o projeto em Verilog, convertendo a descri√ß√£o HDL em uma implementa√ß√£o f√≠sica adequada para a FPGA. Durante esse processo, o compilador realiza a s√≠ntese l√≥gica, o mapeamento e o ajuste de layout (place and route), otimizando as rotas l√≥gicas e a aloca√ß√£o dos recursos internos da FPGA, conforme as recomenda√ß√µes descritas no User Guide: Compiler.

- Refer√™ncia oficial: 
[**Quartus Prime Guide**](https://www.intel.com/content/www/us/en/support/programmable/support-resources/design-software/user-guides.html)

#### üíª FPGA DE1-SoC

- Especifica√ß√µes T√©cnicas:

A placa DE1-SoC, baseada no FPGA Cyclone V SoC (modelo 5CSEMA5F31C6N), conta com aproximadamente 85K elementos l√≥gicos (LEs), 4.450 Kbits de mem√≥ria embarcada e 6 blocos DSP de 18x18 bits. Essas caracter√≠sticas permitem a implementa√ß√£o de designs complexos e o processamento paralelo de dados.

-   Perif√©ricos Utilizados:
    
        
    -   Acesso √† Chip Memory:
        O design utiliza diretamente a mem√≥ria embarcada na FPGA para armazenamento tempor√°rio de dados e matrizes, eliminando a necessidade de interfaces externas para mem√≥ria DDR3.
        

- Refer√™ncia oficial:
[**Manual da Placa**](https://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&No=836&PartNo=4)

### Materiais

#### VGA module

- Refer√™ncia oficial:
[**Verilog VGA module**](https://vanhunteradams.com/DE1/VGA_Driver/Driver.html)






## üöÄ Desenvolvimento e Descri√ß√£o em Alto N√≠vel

## üéõÔ∏è Unidade de Controle

matrizes.

### üìú Instruction Set Architecture



üìã Conjunto de instru√ß√µes do coprocessador:

### üî¢ Instru√ß√µes aritm√©ticas e seus C√≥digos Hexadecimais


### üì• Instru√ß√µes de movimenta√ß√£o de dados e seus C√≥digos Hexadecimais


### üîÑ Etapas de processamento



---

#### ‚öôÔ∏è Execute



---

#### Processamento 



###  Banco de Registradores


#### üñºÔ∏è Diagrama Funcional



#### üìå Tipos de Registradores


## Mem√≥ria

A mem√≥ria desempenha um papel crucial em co-processadores, pois √© nela que as instru√ß√µes e dados necess√°rios para o processamento s√£o acessados. No projeto desenvolvido, utilizamos a **OnChip Memory** da FPGA DE1-SoC. Essa mem√≥ria funciona como uma mem√≥ria RAM simples e possui par√¢metros configur√°veis, permitindo um controle mais eficiente durante o processamento.

Neste projeto, a mem√≥ria foi projetada de forma enxuta, com o √∫nico objetivo de permitir o armazenamento e recebimento de instru√ß√µes e os resultados ap√≥s a finaliza√ß√£o dos processos aritm√©ticos.

#### Par√¢metros de entrada e sa√≠da da mem√≥ria:

- **clk**: Sinal de clock utilizado para sincronizar a mem√≥ria com o restante do sistema.
- **wren**: Sinal de controle que permite a escrita na mem√≥ria.
- **Mem_data**: Canal de 16 bits utilizado para a escrita de dados na mem√≥ria (barramento de 16 bits).
- **q**: Canal de sa√≠da de dados da mem√≥ria, tamb√©m com barramento de 16 bits, respons√°vel por retornar os dados armazenados.
- **address**: Entrada de dados que especifica o endere√ßo de mem√≥ria a ser acessado, permitindo a leitura ou escrita no local desejado.

#### Diagrama da mem√≥ria
---
<p align="center">
<img src="/home/clara/Downloads/diagramaknn" width="350"/>
</p>
---

## Leitura de Dados da Mem√≥ria

A leitura dos dados da mem√≥ria √© realizada diretamente na unidade de controle. A l√≥gica foi projetada para lidar com as matrizes de tamanho fixo 5x5, como mencionado anteriormente, e garantir a efici√™ncia ao acessar os dados sequenciais da mem√≥ria.



### Processo de Leitura:

1. **In√≠cio do processo de leitura:**
   - Quando `loadingMatrix` √© zero, isso significa que ainda n√£o come√ßamos a carregar a matriz. Portanto e o contador de carregamento (`load_counter`) √© zerado.
   - O sinal `read_pending` √© ativado para aguardar a leitura dos dados.
   - Se a matriz que estamos carregando for a matriz A (`Flag_A == 0`), o vetor `matrix1` √© zerado; caso contr√°rio, a matriz B (`matrix2`) √© zerada.

2. **Carregamento dos dados:**
   - O c√≥digo verifica se a matriz ainda n√£o foi completamente carregada. Se n√£o foi, ele usa o contador de carregamento para calcular a linha e a coluna do elemento a ser lido e mapeado na posi√ß√£o correta da mem√≥ria.
   - A matriz √© preenchida utilizando √≠ndices virtuais, `virt_idx1` e `virt_idx2`, que s√£o calculados com base no contador `load_counter`. Esses √≠ndices indicam a posi√ß√£o na matriz de 5x5. Isso √© feito para armazenar e trabalhar com matrizes menores no formato 5x5 de forma correta.
   - O c√≥digo tamb√©m cuida de separar os dados de 16 bits, onde 8 bits s√£o lidos de cada vez. Se for a matriz A (`Flag_A == 0`), os dados s√£o colocados em `matrix1`; caso contr√°rio, em `matrix2`.

3. **Controle de ciclos:**
   - A cada ciclo, o contador de leitura (`load_counter`) √© incrementado em 2, j√° que estamos lendo dois n√∫meros (16 bits) por vez. O endere√ßo de mem√≥ria √© atualizado para acessar a pr√≥xima posi√ß√£o, e a vari√°vel `read_pending` √© ativada novamente.

4. **Finalizando o carregamento:**
   - Quando todos os dados da matriz foram lidos, o sinal `load_done` √© ativado, indicando que o carregamento da matriz foi conclu√≠do.

## Escrita de Dados na Mem√≥ria

A escrita dos dados segue uma l√≥gica semelhante √† da leitura, mas com o objetivo de gravar os resultados ap√≥s o processamento das matrizes. Dessa forma, a escrita das matrizes resultantes s√£o feitas da seguinte forma:


### C√≥digo de Escrita:


### Processo de Escrita:

1. **Controle de Escrita:**
   - A escrita dos dados √© iniciada ao ativar o sinal de controle  `WB`.
   - O vetor `write_data` √© preenchido com os dados do resultado, onde o valor de `result` √© dividido em duas partes. A primeira parte (8 bits) vai para `write_data[15:8]`, e a segunda parte vai para `write_data[7:0]`.

2. **C√°lculo do Endere√ßo de Mem√≥ria:**
   - O endere√ßo de mem√≥ria √© calculado com base no endere√ßo base, somando o offset de cada par de elementos (dois elementos por palavra na mem√≥ria).

3. **Controle de Ciclos de Escrita:**
   - Um contador (`write_counter`) √© usado para controlar o n√∫mero de ciclos de escrita. A cada ciclo, ele √© incrementado at√© atingir o limite de 3, e ent√£o o contador √© resetado.
   - O contador `store_counter` √© utilizado para indicar o elemento atual a ser armazenado.

4. **Finalizando a Escrita:**
   - Quando todos os 25 elementos da matriz 5x5 (representados por `store_counter` at√© o valor 24) forem gravados na mem√≥ria, o sinal `WB` √© desativado, indicando que a escrita foi conclu√≠da, e o sinal `write_done` √© ativado, finalizando o processo.

A implementa√ß√£o das opera√ß√µes de leitura e escrita foram projetadas para otimizar a intera√ß√£o com a mem√≥ria, garantindo uma sincroniza√ß√£o eficiente com o processo de manipula√ß√£o das matrizes. As decis√µes de projeto adotadas, como o controle de ciclos e o uso de buffers de 5x5, permitem que os dados sejam acessados e armazenados de forma eficaz, minimizando desperd√≠cio de ciclos e garantindo a integridade dos resultados ao final do processamento.


### üèóÔ∏è Arquitetura

#### M√≥dulo Principal (`alu.v`)

- Controla todas as opera√ß√µes
- Seleciona sub-m√≥dulos baseado no opcode
- Gerencia sinais de clock, done e overflow

#### Sub-m√≥dulos Especializados

| M√≥dulo                      | Opera√ß√£o | Descri√ß√£o                     |
| --------------------------- | -------- | ----------------------------- |
| `alu_sum_module`            | A + B    | Soma elemento a elemento      |
| `alu_subtraction_module`    | A - B    | Subtra√ß√£o elemento a elemento |
| `alu_multiplication_module` | A √ó B    | Multiplica√ß√£o matricial       |
| `alu_opposite_module`       | -A       | Matriz oposta                 |
| `alu_transpose_module`      | A·µÄ       | Matriz transposta             |
| `alu_scalar_module`         | k¬∑A      | Multiplica√ß√£o por escalar     |
| `alu_determinant_module`    | det(A)   | C√°lculo de determinante       |

### üìä Opera√ß√µes Suportadas



## üîç Detec√ß√£o de Overflow

- Soma/Subtra√ß√£o: Verifica mudan√ßa inesperada no bit de sinal

- Multiplica√ß√£o: Checa se bits superiores diferem do bit de sinal

- Determinante: Verifica se resultado excede 8 bits

## ‚öôÔ∏è Como Executar



#### üì• Como a ULA recebe os dados e sinais de controle

Ap√≥s a UC [(Unidade de Controle)](#unidade-de-controle) obter as matrizes e o opcode da opera√ß√£o, ela realiza a tratativa e o empacotamento dos dados. Em seguida, envia para a ULA 25 bytes, cada um representando um elemento da matriz m√°xima suportada: uma matriz quadrada 5x5.

Essa padroniza√ß√£o permite que a ULA opere diretamente sobre o conjunto de dados sem a necessidade de redefinir estruturas internas para diferentes dimens√µes de matriz.

#### üì§ Como os resultados s√£o manipulados e retornados

A ULA opera sempre com matrizes de ordem 5x5, mesmo quando a matriz de entrada possui uma ordem inferior (como 2x2 ou 4x4). Para opera√ß√µes como soma, subtra√ß√£o, transposi√ß√£o, matriz oposta, produto por escalar e multiplica√ß√£o de matrizes, o tamanho real da matriz n√£o influencia no resultado, pois os elementos fora da regi√£o v√°lida s√£o preenchidos com zero.

Essa estrat√©gia permite que todas as opera√ß√µes sejam realizadas por um √∫nico m√≥dulo, otimizando a l√≥gica e facilitando o suporte a diferentes dimens√µes de matrizes de forma unificada.

Os valores s√£o preenchidos corretamente nos espa√ßos correspondentes da "fita de bytes", que posteriormente √© retornada √† UC (Unidade de Controle) para processamento ou exibi√ß√£o.

#### ‚ö†Ô∏è Aten√ß√£o ao c√°lculo do determinante:

Para a opera√ß√£o de determinante, o tamanho da matriz impacta diretamente o resultado. Por isso, √© utilizado o [Teorema de Laplace](https://pt.wikipedia.org/wiki/Teorema_de_Laplace), e h√° um m√≥dulo dedicado para cada tamanho de matriz, garantindo precis√£o no c√°lculo para matrizes de diferentes ordens.

## üß™ Testes e Simula√ß√µes

A metodologia de Testes usada para garantir o correto funcionamento da ULA foram conduzidos em duas etapas:

Simula√ß√£o via Icarus Verilog, inicialmente, todos os m√≥dulos foram testados de forma isolada utilizando o simulador Icarus Verilog. Ap√≥s a valida√ß√£o por simula√ß√£o, o projeto foi sintetizado no ambiente Quartus Prime II e implementado na placa DE1-SoC, replicando o ambiente final de opera√ß√£o do co-processador.

## üìà An√°lise dos Resultados


## üìâ Desempenho e Uso de Recursos


## üí≠ Discuss√µes e Melhorias Futuras

## ‚úçÔ∏è Colaboradores

Este projeto foi desenvolvido por:

- [**Julia Santana**](https://github.com/) 
- [**Maria Clara**](https://github.com/) 
- [**Vitor D√≥rea**](https://github.com/)
Agradecimentos ao(a) professor(a) [**Angelo Duarte**] pela orienta√ß√£o.

---



# Processamento_de_imagem_FPGA

## üìù Sobre o Projeto 
Objetivo do projeto.

- üìå Funcionalidades

  

  ### üîß Como o Sistema Funciona 


## üìÉ Requisitos 


## üõ†Ô∏è  Arquitetura

### Tecnologias


| Arquivo  | Descri√ß√£o |
| ------------- |:-------------:|
|     |  |
|       |  |
| | |
|   | |
|     | |
|     |  |

