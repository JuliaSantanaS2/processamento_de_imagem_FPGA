# üìù Relat√≥rio T√©cnico - Coprocessador  em FPGA

## üìë Sum√°rio

- üéØ [Objetivos e Requisitos do Problema](#objetivos-e-requisitos-do-problema)
- üõ†Ô∏è [Recursos Utilizados](#recursos-utilizados)
  - üîß [Quartus Prime](#quartus-prime)
  - üíª [FPGA DE1-SoC](#fpga-de1-soc)
- üöÄ [Desenvolvimento e Descri√ß√£o em Alto N√≠vel](#desenvolvimento-e-descri√ß√£o-em-alto-n√≠vel)
  - üéõÔ∏è [Unidade de Controle](#unidade-de-controle)
  - üßÆ [ULA (Unidade L√≥gica e Aritm√©tica)](#unidade-l√≥gica-aritm√©tica)
- üß™ [Testes, Simula√ß√µes, Resultados e Discuss√µes](#testes-simula√ß√µes-resultados-e-discuss√µes)

---

## üåü Introdu√ß√£o



## üéØ Objetivos e Requisitos do Problema



### üìã Requisitos do Projeto
1. O c√≥digo deve ser escrito em linguagem Verilog;
2. O sistema s√≥ poder√° utilizar os componentes dispon√≠veis na placa;
3. Implementa√ß√£o dos seguintes algoritmos para o redimensionamento
das imagens, ambos em passos de 2X:
  3.1. Aproxima√ß√£o (Zoom in)
  3.1.1. Vizinho Mais Pr√≥ximo (Nearest Neighbor Interpolation);
  3.1.2. Replica√ß√£o de Pixel (Pixel Replication / Block Replication)
  3.2. Redu√ß√£o (Zoom out)
  3.2.1. Decima√ß√£o / Amostragem (Nearest Neighbor for Zoom Out)
  3.2.2. M√©dia de Blocos (Block Averaging / Downsampling with Averaging)
1. As imagens s√£o representadas em escala de cinza e cada elemento da imagem
(pixel) dever√° ser representado por um n√∫mero inteiro de 8 bits.
4.5. Devem ser utilizados chaves e/ou bot√µes para determinar a amplia√ß√£o e
redu√ß√£o da imagem;
4.6. O coprocessador deve ser compat√≠vel com o processador ARM (Hard Processor
System - HPS) para viabilizar o desenvolvimento das pr√≥ximas etapas.


## üõ†Ô∏è Recursos Utilizados

### üîß Ferramentas 

#### üíª Quartus Prime

- S√≠ntese e Compila√ß√£o:

O Quartus Prime √© utilizado para compilar o projeto em Verilog, convertendo a descri√ß√£o HDL em uma implementa√ß√£o f√≠sica adequada para a FPGA. Durante esse processo, o compilador realiza a s√≠ntese l√≥gica, o mapeamento e o ajuste de layout (place and route), otimizando as rotas l√≥gicas e a aloca√ß√£o dos recursos internos da FPGA, conforme as recomenda√ß√µes descritas no User Guide: Compiler.

- Refer√™ncia oficial: 
[**Quartus Prime Guide**](https://www.intel.com/content/www/us/en/support/programmable/support-resources/design-software/user-guides.html)

#### üíª FPGA DE1-SoC

- Especifica√ß√µes T√©cnicas:

A placa DE1-SoC, baseada no FPGA Cyclone V SoC (modelo 5CSEMA5F31C6N), conta com aproximadamente 85K elementos l√≥gicos (LEs), 4.450 Kbits de mem√≥ria embarcada e 6 blocos DSP de 18x18 bits. Essas caracter√≠sticas permitem a implementa√ß√£o de designs complexos e o processamento paralelo de dados.

-   Perif√©ricos Utilizados:
    
        
    -   Acesso √† Chip Memory:
        O design utiliza diretamente a mem√≥ria embarcada na FPGA para armazenamento tempor√°rio de dados e matrizes, eliminando a necessidade de interfaces externas para mem√≥ria DDR3.
        

- Refer√™ncia oficial:
[**Manual da Placa**](https://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&No=836&PartNo=4)

### Materiais

#### VGA module

- Refer√™ncia oficial:
[**Verilog VGA module**](https://vanhunteradams.com/DE1/VGA_Driver/Driver.html)






## üöÄ Desenvolvimento e Descri√ß√£o em Alto N√≠vel

## üéõÔ∏è Unidade de Controle

matrizes.

### üìú Instruction Set Architecture



üìã Conjunto de instru√ß√µes do coprocessador:

### üî¢ Instru√ß√µes aritm√©ticas e seus C√≥digos Hexadecimais


### üì• Instru√ß√µes de movimenta√ß√£o de dados e seus C√≥digos Hexadecimais


### üîÑ Etapas de processamento



---

#### ‚öôÔ∏è Execute



---

#### Processamento 



###  Banco de Registradores


#### üñºÔ∏è Diagrama Funcional



#### üìå Tipos de Registradores


## Mem√≥ria

A mem√≥ria desempenha um papel crucial em co-processadores, pois √© nela que as instru√ß√µes e dados necess√°rios para o processamento s√£o acessados. No projeto desenvolvido, utilizamos a **OnChip Memory** da FPGA DE1-SoC. Essa mem√≥ria funciona como uma mem√≥ria RAM simples e possui par√¢metros configur√°veis, permitindo um controle mais eficiente durante o processamento.

Neste projeto, a mem√≥ria foi projetada de forma enxuta, com o √∫nico objetivo de permitir o armazenamento e recebimento de instru√ß√µes e os resultados ap√≥s a finaliza√ß√£o dos processos aritm√©ticos.

#### Par√¢metros de entrada e sa√≠da da mem√≥ria:

- **clk**: Sinal de clock utilizado para sincronizar a mem√≥ria com o restante do sistema.
- **wren**: Sinal de controle que permite a escrita na mem√≥ria.
- **Mem_data**: Canal de 16 bits utilizado para a escrita de dados na mem√≥ria (barramento de 16 bits).
- **q**: Canal de sa√≠da de dados da mem√≥ria, tamb√©m com barramento de 16 bits, respons√°vel por retornar os dados armazenados.
- **address**: Entrada de dados que especifica o endere√ßo de mem√≥ria a ser acessado, permitindo a leitura ou escrita no local desejado.

#### Diagrama da mem√≥ria
---
<p align="center">
<img src="images/RamMem.png" width="350"/>
</p>
---

## Leitura de Dados da Mem√≥ria

A leitura dos dados da mem√≥ria √© realizada diretamente na unidade de controle. A l√≥gica foi projetada para lidar com as matrizes de tamanho fixo 5x5, como mencionado anteriormente, e garantir a efici√™ncia ao acessar os dados sequenciais da mem√≥ria.



### Processo de Leitura:

1. **In√≠cio do processo de leitura:**
   - Quando `loadingMatrix` √© zero, isso significa que ainda n√£o come√ßamos a carregar a matriz. Portanto e o contador de carregamento (`load_counter`) √© zerado.
   - O sinal `read_pending` √© ativado para aguardar a leitura dos dados.
   - Se a matriz que estamos carregando for a matriz A (`Flag_A == 0`), o vetor `matrix1` √© zerado; caso contr√°rio, a matriz B (`matrix2`) √© zerada.

2. **Carregamento dos dados:**
   - O c√≥digo verifica se a matriz ainda n√£o foi completamente carregada. Se n√£o foi, ele usa o contador de carregamento para calcular a linha e a coluna do elemento a ser lido e mapeado na posi√ß√£o correta da mem√≥ria.
   - A matriz √© preenchida utilizando √≠ndices virtuais, `virt_idx1` e `virt_idx2`, que s√£o calculados com base no contador `load_counter`. Esses √≠ndices indicam a posi√ß√£o na matriz de 5x5. Isso √© feito para armazenar e trabalhar com matrizes menores no formato 5x5 de forma correta.
   - O c√≥digo tamb√©m cuida de separar os dados de 16 bits, onde 8 bits s√£o lidos de cada vez. Se for a matriz A (`Flag_A == 0`), os dados s√£o colocados em `matrix1`; caso contr√°rio, em `matrix2`.

3. **Controle de ciclos:**
   - A cada ciclo, o contador de leitura (`load_counter`) √© incrementado em 2, j√° que estamos lendo dois n√∫meros (16 bits) por vez. O endere√ßo de mem√≥ria √© atualizado para acessar a pr√≥xima posi√ß√£o, e a vari√°vel `read_pending` √© ativada novamente.

4. **Finalizando o carregamento:**
   - Quando todos os dados da matriz foram lidos, o sinal `load_done` √© ativado, indicando que o carregamento da matriz foi conclu√≠do.

## Escrita de Dados na Mem√≥ria

A escrita dos dados segue uma l√≥gica semelhante √† da leitura, mas com o objetivo de gravar os resultados ap√≥s o processamento das matrizes. Dessa forma, a escrita das matrizes resultantes s√£o feitas da seguinte forma:


### C√≥digo de Escrita:


### Processo de Escrita:

1. **Controle de Escrita:**
   - A escrita dos dados √© iniciada ao ativar o sinal de controle  `WB`.
   - O vetor `write_data` √© preenchido com os dados do resultado, onde o valor de `result` √© dividido em duas partes. A primeira parte (8 bits) vai para `write_data[15:8]`, e a segunda parte vai para `write_data[7:0]`.

2. **C√°lculo do Endere√ßo de Mem√≥ria:**
   - O endere√ßo de mem√≥ria √© calculado com base no endere√ßo base, somando o offset de cada par de elementos (dois elementos por palavra na mem√≥ria).

3. **Controle de Ciclos de Escrita:**
   - Um contador (`write_counter`) √© usado para controlar o n√∫mero de ciclos de escrita. A cada ciclo, ele √© incrementado at√© atingir o limite de 3, e ent√£o o contador √© resetado.
   - O contador `store_counter` √© utilizado para indicar o elemento atual a ser armazenado.

4. **Finalizando a Escrita:**
   - Quando todos os 25 elementos da matriz 5x5 (representados por `store_counter` at√© o valor 24) forem gravados na mem√≥ria, o sinal `WB` √© desativado, indicando que a escrita foi conclu√≠da, e o sinal `write_done` √© ativado, finalizando o processo.

A implementa√ß√£o das opera√ß√µes de leitura e escrita foram projetadas para otimizar a intera√ß√£o com a mem√≥ria, garantindo uma sincroniza√ß√£o eficiente com o processo de manipula√ß√£o das matrizes. As decis√µes de projeto adotadas, como o controle de ciclos e o uso de buffers de 5x5, permitem que os dados sejam acessados e armazenados de forma eficaz, minimizando desperd√≠cio de ciclos e garantindo a integridade dos resultados ao final do processamento.


### üèóÔ∏è Arquitetura

#### M√≥dulo Principal (`alu.v`)

- Controla todas as opera√ß√µes
- Seleciona sub-m√≥dulos baseado no opcode
- Gerencia sinais de clock, done e overflow

#### Sub-m√≥dulos Especializados

| M√≥dulo                      | Opera√ß√£o | Descri√ß√£o                     |
| --------------------------- | -------- | ----------------------------- |
| `alu_sum_module`            | A + B    | Soma elemento a elemento      |
| `alu_subtraction_module`    | A - B    | Subtra√ß√£o elemento a elemento |
| `alu_multiplication_module` | A √ó B    | Multiplica√ß√£o matricial       |
| `alu_opposite_module`       | -A       | Matriz oposta                 |
| `alu_transpose_module`      | A·µÄ       | Matriz transposta             |
| `alu_scalar_module`         | k¬∑A      | Multiplica√ß√£o por escalar     |
| `alu_determinant_module`    | det(A)   | C√°lculo de determinante       |

### üìä Opera√ß√µes Suportadas



## üîç Detec√ß√£o de Overflow

- Soma/Subtra√ß√£o: Verifica mudan√ßa inesperada no bit de sinal

- Multiplica√ß√£o: Checa se bits superiores diferem do bit de sinal

- Determinante: Verifica se resultado excede 8 bits

## ‚öôÔ∏è Como Executar



#### üì• Como a ULA recebe os dados e sinais de controle

Ap√≥s a UC [(Unidade de Controle)](#unidade-de-controle) obter as matrizes e o opcode da opera√ß√£o, ela realiza a tratativa e o empacotamento dos dados. Em seguida, envia para a ULA 25 bytes, cada um representando um elemento da matriz m√°xima suportada: uma matriz quadrada 5x5.

Essa padroniza√ß√£o permite que a ULA opere diretamente sobre o conjunto de dados sem a necessidade de redefinir estruturas internas para diferentes dimens√µes de matriz.

#### üì§ Como os resultados s√£o manipulados e retornados

A ULA opera sempre com matrizes de ordem 5x5, mesmo quando a matriz de entrada possui uma ordem inferior (como 2x2 ou 4x4). Para opera√ß√µes como soma, subtra√ß√£o, transposi√ß√£o, matriz oposta, produto por escalar e multiplica√ß√£o de matrizes, o tamanho real da matriz n√£o influencia no resultado, pois os elementos fora da regi√£o v√°lida s√£o preenchidos com zero.

Essa estrat√©gia permite que todas as opera√ß√µes sejam realizadas por um √∫nico m√≥dulo, otimizando a l√≥gica e facilitando o suporte a diferentes dimens√µes de matrizes de forma unificada.

Os valores s√£o preenchidos corretamente nos espa√ßos correspondentes da "fita de bytes", que posteriormente √© retornada √† UC (Unidade de Controle) para processamento ou exibi√ß√£o.

#### ‚ö†Ô∏è Aten√ß√£o ao c√°lculo do determinante:

Para a opera√ß√£o de determinante, o tamanho da matriz impacta diretamente o resultado. Por isso, √© utilizado o [Teorema de Laplace](https://pt.wikipedia.org/wiki/Teorema_de_Laplace), e h√° um m√≥dulo dedicado para cada tamanho de matriz, garantindo precis√£o no c√°lculo para matrizes de diferentes ordens.

## üß™ Testes e Simula√ß√µes

A metodologia de Testes usada para garantir o correto funcionamento da ULA foram conduzidos em duas etapas:

Simula√ß√£o via Icarus Verilog, inicialmente, todos os m√≥dulos foram testados de forma isolada utilizando o simulador Icarus Verilog. Ap√≥s a valida√ß√£o por simula√ß√£o, o projeto foi sintetizado no ambiente Quartus Prime II e implementado na placa DE1-SoC, replicando o ambiente final de opera√ß√£o do co-processador.

## üìà An√°lise dos Resultados


## üìâ Desempenho e Uso de Recursos


## üí≠ Discuss√µes e Melhorias Futuras

## ‚úçÔ∏è Colaboradores

Este projeto foi desenvolvido por:

- [**Julia Santana**](https://github.com/) 
- [**Maria Clara**](https://github.com/) 
- [**Vitor D√≥rea**](https://github.com/)
Agradecimentos ao(a) professor(a) [**Angelo Duarte**] pela orienta√ß√£o.

---








O objetivo em um arquivo README pode estar no bloco inicial de informa√ß√µes contendo:

    Descri√ß√£o t√©cnica do objetivo do c√≥digo.
    Links para conte√∫dos t√©cnicos adicionais.
    Link para materiais relacionados ao neg√≥cio, como o Modelo de neg√≥cio, Personas, Modelo de dom√≠nio, √âpicos e Hist√≥ria

Para conte√∫do adicional, pode-se tamb√©m fazer o uso de arquivos Markdown e eles podem estar em um diret√≥rio docs na raiz do projeto.

Por exemplo, arquiteturas monol√≠ticas podem ter artefatos diferentes de arquiteturas em microsservi√ßos, onde a primeira poder√° ter apenas uma documenta√ß√£o da sua arquitetura salva no pr√≥prio projeto e a segunda poder√° ter uma documenta√ß√£o geral de estrutura√ß√£o dos servi√ßos salva externamente.

Para ambas situa√ß√µes, h√° algumas boas pr√°ticas que podem ser aplicadas:

    Oferecer uma breve descri√ß√£o sobre a arquitetura utilizada.
    Quando a arquitetura segue um padr√£o ou estilo conceitual, n√£o √© necess√°rio detalhar o conceito, basta citar o padr√£o ou estilo criando um link para um conte√∫do confi√°vel que detalhe o mesmo.
    Caso a documenta√ß√£o de arquitetura esteja em um arquivo pr√≥prio, cit√°-lo no README com um link para o mesmo.
    Fazer uso de desenhos para representar a arquitetura. Esta pr√°tica est√° detalhada no tema Desenhos t√©cnicos no guia.
    Citar a linguagem e frameworks utilizados, informando no m√°ximo a sua vers√£o major. Isso porque normalmente o detalhe das vers√µes est√° no arquivo de configura√ß√£o da ferramenta de depend√™ncias utilizada, logo n√£o √© necess√°rio ter informa√ß√µes duplicadas.
    Informar as depend√™ncias do projeto, sejam as de outros servi√ßos, projetos ou bibliotecas. Para caso de bibliotecas, o i

Acesso e execu√ß√£o do c√≥digo

Saber onde est√° o c√≥digo fonte parece algo simples, mas muitas vezes se torna uma dificuldade em times de desenvolvimento.

A forma para documentar essa quest√£o pode variar de acordo com a ferramenta utilizada para versionar o c√≥digo. No passado, ferramentas focadas nesse assunto n√£o proviam portais de acesso aos usu√°rios, era necess√°rio registrar o local do projeto em outros documentos ou apenas na mem√≥ria.

Atualmente, ferramentas como as j√° citadas GitHub, GitLab, BitBucket, permitiram uma grande evolu√ß√£o na gest√£o de c√≥digo fonte, o que tornou dispens√°vel documentos auxiliares para esse tipo de informa√ß√£o.

O recomend√°vel √© o uso desta ferramentas, onde desenvolvedores(as) com seus usu√°rios poder√£o ver todos os projetos com c√≥digo fonte aos quais possuem acesso.

Ainda assim, √© importante seguir algumas boas pr√°ticas para facilitar a localiza√ß√£o do projeto:

    Uso de nomes adequados ao objetivo do c√≥digo e que evitem confus√µes a desenvolvedores(as).
    Uso do campo de descri√ß√£o do projeto com conte√∫do inicial usado no README.
    Organiza√ß√£o dos agrupamentos e permiss√µes de acesso. Dar acesso a todos os projetos sem qualquer crit√©rio polui a vis√£o da lista de projetos.

Nas informa√ß√µes de execu√ß√£o do projeto, o README pode conter:

    Configura√ß√µes necess√°rias no ambiente para rodar com sucesso o projeto.
    Instru√ß√µes para uso da ferramenta de build adotada no projeto.
    Os comandos necess√°rios para rodar o projeto localmente e demais scripts auxiliares.


Altera√ß√µes, testes e valida√ß√µes

Uma das atividades mais realizadas por desenvolvedores(as) sobre um c√≥digo fonte ser√° a de modific√°-lo, logo √© essencial que esteja documentado o processo utilizado pelo time para alterar, testar e validar suas altera√ß√µes, sejam com testes automatizados (que √© o mais adequado) ou acessando e usando o sistema localmente.
documentar:

    Comandos auxiliares para gera√ß√£o/carregamento de cen√°rios de dados.
    Dados de autentica√ß√£o para acesso ao sistema, considerando inclusive informa√ß√µes de usu√°rios de pap√©is diferentes quando existentes.

Atualiza√ß√£o e monitoramento

Para atualizar o software em um ambiente, normalmente h√° passos que devem ser seguidos e √© importante que essas informa√ß√µes estejam documentadas.

Ao colocar em um ambiente uma nova vers√£o, principalmente em produ√ß√£o, desenvolvedores(as) precisam tamb√©m saber como monitorar e verificar problemas no software caso eles ocorram.

Essas informa√ß√µes normalmente est√£o documentadas fora do projeto, √© adequado ent√£o fazer o link para tais conte√∫dos.

Al√©m do como documentar h√° tamb√©m o desafio de manter e utilizar a documenta√ß√£o t√©cnica.

Para manter uma documenta√ß√£o atualizada √© necess√°rio comprometimento e responsabilidade dos times para tal atividade. Uma boa pr√°tica √© documentar antes de implementar. Isso evita cair na armadilha de passar para outras tarefas porque a anterior j√° parece estar pronta. Nesse caso documentar, quando necess√°rio, se torna o trabalho inicial de uma tarefa de implementa√ß√£o, semelhante ao TDD para testes automatizados.

Outro aspecto que estimula os times manterem atualizadas as documenta√ß√µes √© perceberem que elas s√£o utilizadas. Nesse sentido deve-se buscar:

    Indicar a documenta√ß√£o sempre que as pessoas perguntarem sobre algo que esteja devidamente documentado. Se h√° documenta√ß√£o n√£o deve-se usar muito tempo para repetir verbalmente informa√ß√µes contidas nelas.
    Usar a documenta√ß√£o em reuni√µes e momentos de decis√µes onde elas possam colaborar para clareza das conversas.
    Dar espa√ßo a todos para contribu√≠rem nas documenta√ß√µes, de forma que possam edit√°-las sempre que houver algo novo ou a ser corrigido.

No sentido inverso do tema, h√° alguns pontos aos quais deve-se evitar gerar documenta√ß√µes auxiliares pois estas normalmente n√£o s√£o utilizadas e s√£o dif√≠ceis de serem mantidas. Abaixo segue alguns:

    C√≥digo fonte: Um ponto pol√™mico entre desenvolvedores(as), cuja quest√£o n√£o est√° em documentar ou n√£o o c√≥digo fonte, mas sim o porqu√™ e como documentar. Um c√≥digo bem escrito, que segue as pr√°ticas de C√≥digo Limpo (Clean Code) teoricamente n√£o precisa de documenta√ß√£o. Ainda assim h√° casos onde uma documenta√ß√£o pode ser √∫til, por√©m ela precisa ser simples. Se ela se torna complexa provavelmente √© porque o c√≥digo est√° complexo.
    Modelagem detalhada: √â v√°lido ter documenta√ß√£o sobre a modelagem da solu√ß√£o, seja de entidades, de componentes, dentre outros. Por√©m ela deve apenas prover a vis√£o resumida do todo. Detalhes que s√£o vol√°teis normalmente se tornam desatualizados na documenta√ß√£o. O c√≥digo √© a fonte mais confi√°vel.
    Diagramas de classe: Ter um diagrama sobre as classes base de um projeto pode ser √∫til, por√©m representar todas as classes normalmente se torna uma documenta√ß√£o com pouca utilidade e desatualizada. A prefer√™ncia normalmente ser√° ir diretamente ao c√≥digo fonte.
    Funcionalidades: Documenta√ß√£o t√©cnica sobre funcionalidades pode ser v√°lida para quest√µes n√£o mapeadas a n√≠vel de neg√≥cio. O importante √© n√£o repetir conte√∫do j√° presente em Hist√≥rias, Casos de uso, ou outras documenta√ß√µes de neg√≥cio e requis√≠tos, pois √© normal as funcionalidades evolu√≠rem e tais documenta√ß√µes t√©cnicas n√£o.

Uma boa documenta√ß√£o t√©cnica contribui para efici√™ncia e escala de times de desenvolvimento. Criar e mant√™-la √© um sinal de profissionalismo e maturidade.

O que e como documentar pode ser sempre adaptado conforme as necessidades, inclusive complementado com o tema Desenho T√©cnico, para buscar o nivelamento de conhecimento, diminui√ß√£o do tempo usado com perguntas repetidas e evitar informa√ß√µes retidas apenas ‚Äúna mem√≥ria das pessoas‚Äù.

# Processamento_de_imagem_FPGA

## üìù Sobre o Projeto 
Objetivo do projeto.

- üìå Funcionalidades

  

  ### üîß Como o Sistema Funciona 


## üìÉ Requisitos 


## üõ†Ô∏è  Arquitetura

### Tecnologias


| Arquivo  | Descri√ß√£o |
| ------------- |:-------------:|
| main.py      | Inicializa rotas, middlewares e configura√ß√µes |
| server.py      | Entrada do uvicorn para execu√ß√£o do servidor |
| Dockerfile      | Configura o ambiente Docker para build da aplica√ß√£o |
| docker-compose.yml     | Orquestra os servi√ßos Docker (como banco de dados e o backend em si)|
| requirements.txt      | Lista de depend√™ncias Python da aplica√ß√£o |
| pyproject.toml      | Configura√ß√£o do projeto e suas depend√™ncias via poetry |




## üöÄ Como Rodar o Projeto (Passo a Passo Simples)

### Pr√©-requisitos:
- Python 3.8+
- Docker 

### Passo a Passo:

* **Configurar git**
  ```  
  git config --global user.email "example@mail.com"  
  ```  
  ```  
  git config --global user.name "Your Name"  
  ```  
  - Fazer um fork do projeto

1. **Baixar o c√≥digo**:
   ```
   git clone https://github.com/EcompJr/pj-hans-back
   git init
   ```

2. **Configurar ambiente**:

 - Depend√™ncias

   ```
      sudo apt install -y make build-essential libssl-dev zlib1g-dev \
    libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm \
    libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev \
    libffi-dev liblzma-dev git
   ```

  - Instala√ß√£o
   ```
    git clone https://github.com/pyenv/pyenv.git ~/.pyenv
  ```
  - Configura√ß√£o no shell
  ```
    nano ~/.bashrc
  ```

   ```
    export PYENV_ROOT="$HOME/.pyenv"
  export PATH="$PYENV_ROOT/bin:$PATH"
  eval "$(pyenv init --path)"
  eval "$(pyenv init -)"
  ```
  - Atualizar o shell
  ```
      source ~/.bashrc   
  ```
  - Verifica√ß√£o
  ```
      pyenv --version   
  ```
  - **Configura√ß√£o do poetry**
  
  Depend√™ncias
  ```
  sudo apt install -y curl python3-pip
  Instala√ß√£o
  curl -sSL https://install.python-poetry.org | python3 -
 ```
  Configura√ß√£o
```
  export PATH="$HOME/.local/bin:$PATH"
  source ~/.bashrc
 ```
Verificar se foi instalado corretamente
 ```
poetry --version
 ```

3. **Instalar as depend√™ncias:**
  ```
  pip install -r requirements.txt  
  ```

  - Configurar as vari√°veis de ambiente do app. 
  
 4. **Verificar se h√° um arquivo `.env` na raiz do projeto com o seguinte conte√∫do m√≠nimo:**
  
  A forma geral √©: DB_URL=TIPO_BD://USUARIO:SENHA@HOST:PORTA/NOME_BD?PARAM1=valor&PARAM2=valor
  ```
  echo '
  POSTGRES_USER=admin_ecompjr
  POSTGRES_PASSWORD=EcompJr123
  POSTGRES_DB=postgres
  SERVER_DATABASE_HOST=localhost
  APP_NAME=my-app
  APP_PORT=8080' >> .env
  ```

 5. **Instalar a interface de linha de comando do docker-compose:**
  ```
  sudo rm /usr/local/bin/docker-compose
  ```
  ```
  sudo ln -s /Applications/Docker.app/Contents/Resources/cli-plugins/docker-compose /usr/local/bin/docker-compose
  ``` 

6. **Configurar ferramenta de banco de dados**:
  

  - Reiniciar WSL

  ```
  wsl --shutdown
  wsl -d Ubuntu
  ```

  - Inicar e testar 

  ```
  sudo service docker start
  docker run hello-world
  ```

  -Subir banco de dados
```
  docker compose up -d  
  ```
  
  - Para buildar imagens dos containers
  ```
  docker compose build
  ``` 
  - Para parar os containers
  ```
  docker compose down
  ``` 

7. **Executar as migra√ß√µes**(Cria as tabelas):
  ```
  docker exec <nome_do_container> aerich upgrade
  ```

8. **Ligar o servidor**(Inicia o servidor):
   ```hypercorn server:app --reload  # Inicia o sistema com auto-recarregamento```

10. **Acessar o servidor**:**
   ```http://localhost:8080/docs``` 


- Para encerrar a aplica√ß√£o:
  ```
  Ctrl+C
  ```

  - Para encerrar o banco de dados:
  ```
  docker-compose down
  ```
   
  - Para rodar os testes:
  ```
  pytest -v
  ```
